<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-07-11 Tue 15:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Rendering</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Chris Hodapp" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.20/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">3D Rendering</h1>

<div id="outline-container-org537595e" class="outline-2">
<h2 id="org537595e"><span class="section-number-2"> 3</span> 3D Rendering</h2>
<div class="outline-text-2" id="text-1">
<p>
If \(a^2=b\) and \( b=2 \), then the solution must be
either \[ a=+\sqrt{2} \] or \[ a=-\sqrt{2} \].
</p>

\begin{equation}
x=\sqrt{b}
\end{equation}
</div>

<div id="outline-container-org8c5d820" class="outline-3">
<h3 id="org8c5d820"><span class="section-number-3"> 3.1</span> Sphere example</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-1' mode="ace/mode/glsl" readonly="true">uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

// camera attributes
// cameraDirection and cameraUp MUST be normalized
// (ie. their length must be equal to 1)
const vec3 cameraPosition_ = vec3(0.0, 0.0, 10.0);
const vec3 cameraDirection = vec3(0.0, 0.0, -1.0);
const vec3 cameraUp = vec3(0.0, 1.0, 0.0);

// ray computation vars
const float PI = 3.14159265359;
const float fov = 50.0;
const float fovx = PI * fov / 360.0;
float fovy = fovx * resolution.y/resolution.x;
float ulen = tan(fovx);
float vlen = tan(fovy);

float distanceToNearestSurface(vec3 p){
    return length(p) - 1.0;
}

bool intersectsWithWorld(vec3 p, vec3 dir){
  float dist = 0.0;
  for(int i = 0; i &lt; 20; i++){
    float nearest = distanceToNearestSurface(p + dir*dist);
    if(nearest &lt; 0.01) return true;
    dist += nearest;
  }
  return false;
}

void main()
{
    vec2 uv = gl_FragCoord.xy/resolution.xy;
  
    // generate the ray for this pixel
    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);
    vec3 nright = normalize(cross(cameraUp, cameraDirection));
    vec3 pixel = cameraPosition_ + cameraDirection +
                 nright*camUV.x*ulen + cameraUp*camUV.y*vlen;
    vec3 rayDirection = normalize(pixel - cameraPosition_);
    
    float collidedWithWorld = 0.0;
    if(intersectsWithWorld(cameraPosition_, rayDirection))
        collidedWithWorld = 1.0;
    
    gl_FragColor = vec4(collidedWithWorld, 0.0, 0.0, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-1' style='display:none'>uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

// camera attributes
// cameraDirection and cameraUp MUST be normalized
// (ie. their length must be equal to 1)
const vec3 cameraPosition_ = vec3(0.0, 0.0, 10.0);
const vec3 cameraDirection = vec3(0.0, 0.0, -1.0);
const vec3 cameraUp = vec3(0.0, 1.0, 0.0);

// ray computation vars
const float PI = 3.14159265359;
const float fov = 50.0;
const float fovx = PI * fov / 360.0;
float fovy = fovx * resolution.y/resolution.x;
float ulen = tan(fovx);
float vlen = tan(fovy);

float distanceToNearestSurface(vec3 p){
    return length(p) - 1.0;
}

bool intersectsWithWorld(vec3 p, vec3 dir){
  float dist = 0.0;
  for(int i = 0; i &lt; 20; i++){
    float nearest = distanceToNearestSurface(p + dir*dist);
    if(nearest &lt; 0.01) return true;
    dist += nearest;
  }
  return false;
}

void main()
{
    vec2 uv = gl_FragCoord.xy/resolution.xy;
  
    // generate the ray for this pixel
    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);
    vec3 nright = normalize(cross(cameraUp, cameraDirection));
    vec3 pixel = cameraPosition_ + cameraDirection +
                 nright*camUV.x*ulen + cameraUp*camUV.y*vlen;
    vec3 rayDirection = normalize(pixel - cameraPosition_);
    
    float collidedWithWorld = 0.0;
    if(intersectsWithWorld(cameraPosition_, rayDirection))
        collidedWithWorld = 1.0;
    
    gl_FragColor = vec4(collidedWithWorld, 0.0, 0.0, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-1').text());">Use code &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org275ea58" class="outline-3">
<h3 id="org275ea58"><span class="section-number-3"> 3.2</span> Distance Bounds &amp; Distance Fields</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-org1127134" class="outline-4">
<h4 id="org1127134"><span class="section-number-4"> 3.2.1</span> Why a sphere tracer?</h4>
</div>
</div>

<div id="outline-container-orgfa1c94d" class="outline-3">
<h3 id="orgfa1c94d"><span class="section-number-3"> 3.3</span> Transformations</h3>
<div class="outline-text-3" id="text-1-3">
</div>

<div id="outline-container-orgc28a64e" class="outline-4">
<h4 id="orgc28a64e"><span class="section-number-4"> 3.3.1</span> Scaling</h4>
</div>

<div id="outline-container-orge48c2e7" class="outline-4">
<h4 id="orge48c2e7"><span class="section-number-4"> 3.3.2</span> Translation</h4>
</div>

<div id="outline-container-org51113a0" class="outline-4">
<h4 id="org51113a0"><span class="section-number-4"> 3.3.3</span> Rotation</h4>
</div>

<div id="outline-container-orgea72927" class="outline-4">
<h4 id="orgea72927"><span class="section-number-4"> 3.3.4</span> Shearing</h4>
</div>

<div id="outline-container-org36bdf0e" class="outline-4">
<h4 id="org36bdf0e"><span class="section-number-4"> 3.3.5</span> Vectors &amp; Matrices</h4>
<div class="outline-text-4" id="text-1-3-5">
</div>
</div>
</div>

<div id="outline-container-orge818a90" class="outline-3">
<h3 id="orge818a90"><span class="section-number-3"> 3.4</span> Constructive Solid Geometry</h3>
</div>

<div id="outline-container-org26b150d" class="outline-3">
<h3 id="org26b150d"><span class="section-number-3"> 3.5</span> Domain Warping</h3>
</div>

<div id="outline-container-org3375525" class="outline-3">
<h3 id="org3375525"><span class="section-number-3"> 3.6</span> Domain Repetition</h3>
</div>

<div id="outline-container-org88daac9" class="outline-3">
<h3 id="org88daac9"><span class="section-number-3"> 3.7</span> Summary</h3>
<div class="outline-text-3" id="text-1-7">
<p>
This concludes the tutorial - at least, until I write more.
</p>

<p>
I mentioned that distance fields were a sort of extension of what we
looked at in the last section - particularly, of what we can do with
functions that map points in space to something (color, or a distance
bound, for instance).  Another application of this same principle can
be found in the <a target='_blank' href="https://www.cs.jhu.edu/~subodh/458/p253-perlin.pdf">Hypertexture</a> approach of Perlin and Hoffert - in which
a function maps points in 3D space to <b>density</b> at that point.
</p>

<p>
3D rendering is a subject both broad and deep, and this tutorial
covers just a narrow part of one aspect of them.  The next section
gives a handful of references that may be good starting points.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
