<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-07-12 Wed 16:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Rendering</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Chris Hodapp" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.20/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">3D Rendering</h1>

<div id="outline-container-org393e9ff" class="outline-2">
<h2 id="org393e9ff"><span class="section-number-2"> 3</span> 3D Rendering</h2>
<div class="outline-text-2" id="text-1">
<p>
If \(a^2=b\) and \( b=2 \), then the solution must be
either \[ a=+\sqrt{2} \] or \[ a=-\sqrt{2} \].
</p>

\begin{equation}
x=\sqrt{b}
\end{equation}
</div>

<div id="outline-container-orge2d74f9" class="outline-3">
<h3 id="orge2d74f9"><span class="section-number-3"> 3.1</span> Sphere example</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-1' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float freq;
uniform float freq2;

vec2 map(in vec3 pos)
{
    vec3 pos_ = vec3(mod(pos.x, 2.0) - 1.0, pos.y, mod(pos.z, 2.0) - 1.0);
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);
    vec2 res = opU(vec2(sdPlane(pos), 1.0),
                   vec2(udRoundBox(pos3-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05), 7.0));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
	float time = 15.0 + time;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-1' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 0.1,
       "min": -5,
       "max": 5,
       "name": "freq",
       "GUIName": "Freq"
   },
   {
       "type": "float",
       "value": 0.1,
       "min": -1,
       "max": 1,
       "name": "freq2",
       "GUIName": "Freq2"
   }   
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float freq;
uniform float freq2;

vec2 map(in vec3 pos)
{
    vec3 pos_ = vec3(mod(pos.x, 2.0) - 1.0, pos.y, mod(pos.z, 2.0) - 1.0);
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);
    vec2 res = opU(vec2(sdPlane(pos), 1.0),
                   vec2(udRoundBox(pos3-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05), 7.0));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
	float time = 15.0 + time;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-1').text());">Use code &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgd379505" class="outline-3">
<h3 id="orgd379505"><span class="section-number-3"> 3.2</span> Distance Bounds &amp; Distance Fields</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-org98679a8" class="outline-4">
<h4 id="org98679a8"><span class="section-number-4"> 3.2.1</span> Why a sphere tracer?</h4>
</div>
</div>

<div id="outline-container-orgacf228d" class="outline-3">
<h3 id="orgacf228d"><span class="section-number-3"> 3.3</span> Transformations</h3>
<div class="outline-text-3" id="text-1-3">
</div>

<div id="outline-container-orgf268861" class="outline-4">
<h4 id="orgf268861"><span class="section-number-4"> 3.3.1</span> Scaling</h4>
</div>

<div id="outline-container-org6298868" class="outline-4">
<h4 id="org6298868"><span class="section-number-4"> 3.3.2</span> Translation</h4>
</div>

<div id="outline-container-org2c97db2" class="outline-4">
<h4 id="org2c97db2"><span class="section-number-4"> 3.3.3</span> Rotation</h4>
</div>

<div id="outline-container-orgf9cf3d0" class="outline-4">
<h4 id="orgf9cf3d0"><span class="section-number-4"> 3.3.4</span> Shearing</h4>
</div>

<div id="outline-container-org865a9a3" class="outline-4">
<h4 id="org865a9a3"><span class="section-number-4"> 3.3.5</span> Vectors &amp; Matrices</h4>
<div class="outline-text-4" id="text-1-3-5">
</div>
</div>
</div>

<div id="outline-container-orgdd3a349" class="outline-3">
<h3 id="orgdd3a349"><span class="section-number-3"> 3.4</span> Constructive Solid Geometry</h3>
</div>

<div id="outline-container-org03e3db3" class="outline-3">
<h3 id="org03e3db3"><span class="section-number-3"> 3.5</span> Domain Warping</h3>
</div>

<div id="outline-container-orgb8878ee" class="outline-3">
<h3 id="orgb8878ee"><span class="section-number-3"> 3.6</span> Domain Repetition</h3>
</div>

<div id="outline-container-org29dc2b1" class="outline-3">
<h3 id="org29dc2b1"><span class="section-number-3"> 3.7</span> Summary</h3>
<div class="outline-text-3" id="text-1-7">
<p>
This concludes the tutorial - at least, until I write more.
</p>

<p>
I mentioned that distance fields were a sort of extension of what we
looked at in the last section - particularly, of what we can do with
functions that map points in space to something (color, or a distance
bound, for instance).  Another application of this same principle can
be found in the <a target='_blank' href="https://www.cs.jhu.edu/~subodh/458/p253-perlin.pdf">Hypertexture</a> approach of Perlin and Hoffert - in which
a function maps points in 3D space to <b>density</b> at that point.
</p>

<p>
3D rendering is a subject both broad and deep, and this tutorial
covers just a narrow part of one aspect of them.  The next section
gives a handful of references that may be good starting points.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
