<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-07-11 Tue 17:59 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Rendering</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Chris Hodapp" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.20/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">3D Rendering</h1>

<div id="outline-container-org610559e" class="outline-2">
<h2 id="org610559e"><span class="section-number-2"> 3</span> 3D Rendering</h2>
<div class="outline-text-2" id="text-1">
<p>
If \(a^2=b\) and \( b=2 \), then the solution must be
either \[ a=+\sqrt{2} \] or \[ a=-\sqrt{2} \].
</p>

\begin{equation}
x=\sqrt{b}
\end{equation}
</div>

<div id="outline-container-org0121708" class="outline-3">
<h3 id="org0121708"><span class="section-number-3"> 3.1</span> Sphere example</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-1' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

vec2 map(in vec3 pos)
{
    vec2 res = opU(vec2(sdPlane(pos), 1.0),
                   vec2(sdSphere(pos-vec3(0.0,0.5,0.0), 1.0), 46.9));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
	float time = 15.0 + time;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, -0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-1' style='display:none'>#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

vec2 map(in vec3 pos)
{
    vec2 res = opU(vec2(sdPlane(pos), 1.0),
                   vec2(sdSphere(pos-vec3(0.0,0.5,0.0), 1.0), 46.9));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
	float time = 15.0 + time;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, -0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-1').text());">Use code &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgb8de9ae" class="outline-3">
<h3 id="orgb8de9ae"><span class="section-number-3"> 3.2</span> Distance Bounds &amp; Distance Fields</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-org0f1d988" class="outline-4">
<h4 id="org0f1d988"><span class="section-number-4"> 3.2.1</span> Why a sphere tracer?</h4>
</div>
</div>

<div id="outline-container-org514aac3" class="outline-3">
<h3 id="org514aac3"><span class="section-number-3"> 3.3</span> Transformations</h3>
<div class="outline-text-3" id="text-1-3">
</div>

<div id="outline-container-orgf5c4257" class="outline-4">
<h4 id="orgf5c4257"><span class="section-number-4"> 3.3.1</span> Scaling</h4>
</div>

<div id="outline-container-org9461b74" class="outline-4">
<h4 id="org9461b74"><span class="section-number-4"> 3.3.2</span> Translation</h4>
</div>

<div id="outline-container-org5ce7440" class="outline-4">
<h4 id="org5ce7440"><span class="section-number-4"> 3.3.3</span> Rotation</h4>
</div>

<div id="outline-container-org6103645" class="outline-4">
<h4 id="org6103645"><span class="section-number-4"> 3.3.4</span> Shearing</h4>
</div>

<div id="outline-container-org8f01e3b" class="outline-4">
<h4 id="org8f01e3b"><span class="section-number-4"> 3.3.5</span> Vectors &amp; Matrices</h4>
<div class="outline-text-4" id="text-1-3-5">
</div>
</div>
</div>

<div id="outline-container-orgf50d7de" class="outline-3">
<h3 id="orgf50d7de"><span class="section-number-3"> 3.4</span> Constructive Solid Geometry</h3>
</div>

<div id="outline-container-org0e3ecbc" class="outline-3">
<h3 id="org0e3ecbc"><span class="section-number-3"> 3.5</span> Domain Warping</h3>
</div>

<div id="outline-container-orge875516" class="outline-3">
<h3 id="orge875516"><span class="section-number-3"> 3.6</span> Domain Repetition</h3>
</div>

<div id="outline-container-orgb0ee722" class="outline-3">
<h3 id="orgb0ee722"><span class="section-number-3"> 3.7</span> Summary</h3>
<div class="outline-text-3" id="text-1-7">
<p>
This concludes the tutorial - at least, until I write more.
</p>

<p>
I mentioned that distance fields were a sort of extension of what we
looked at in the last section - particularly, of what we can do with
functions that map points in space to something (color, or a distance
bound, for instance).  Another application of this same principle can
be found in the <a target='_blank' href="https://www.cs.jhu.edu/~subodh/458/p253-perlin.pdf">Hypertexture</a> approach of Perlin and Hoffert - in which
a function maps points in 3D space to <b>density</b> at that point.
</p>

<p>
3D rendering is a subject both broad and deep, and this tutorial
covers just a narrow part of one aspect of them.  The next section
gives a handful of references that may be good starting points.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
