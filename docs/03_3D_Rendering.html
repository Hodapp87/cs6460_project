<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-07-17 Mon 13:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Rendering</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Chris Hodapp" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.20/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">3D Rendering</h1>

<div id="outline-container-orga51dc42" class="outline-2">
<h2 id="orga51dc42"><span class="section-number-2"> 3</span> 3D Rendering</h2>
<div class="outline-text-2" id="text-1">
<p>
In the last section, we dealt with a class of functions which mapped
2D space (i.e. a pixel location) to color values.  In this section, we
generalize this a bit, and deal with functions that map 3D space to
something.
</p>

<p>
First, though, consider a (far-fetched) thought experiment.  Suppose
you're outside and you need to trace out some strange geographical
boundary - maybe an irregular, invisible property line.  For whatever
reason, you don't even have a map.  What you do have is a precise but
rather strange GPS device&#x2026; and all it can do is tell you, whenever
you need, the shortest distance you could move in order to reach the
nearest part of that boundary.  It doesn't tell you which direction.
If it tells you "21 feet", all it means is that in some direction, the
boundary is exactly 21 feet away, and it's not closer than that in any
other direction.
</p>

<p>
Assume you have some other basic implements, like a tape measure and a
can of spray paint, and assume that you at least know you're starting
somewhere inside this boundary.  Now, how could you go about finding
and marking this boundary (or something fairly close to it)?
</p>

<p>
There are probably many different answers, but here is one method to
consider:
</p>

<ol class="org-ol">
<li>Mark your starting point on the ground.</li>
<li>Pick any direction.</li>
<li>Get the nearest-distance measurement from the GPS.</li>
<li>Walk in a straight line in the chosen direction until you've
covered the distance the GPS told you.</li>
<li>Go back to step 3, using the same direction. Once the GPS gives
distance measurements that are very small (e.g. one inch), stop.</li>
<li>Wherever you are, make a marking on the ground.</li>
<li>Return to your starting point.</li>
<li>Pick a new direction, rotated very slightly from the last time
(e.g. just 1/2 degree clockwise).</li>
<li>Repeat step 3.  Once you've returned to your starting direction,
stop.</li>
</ol>

<p>
This is very pain-staking and tedious - but the end result is that
you've marked off the entire boundary, at 1/2 degree increments, to
within an inch. (It's possible you'll miss spots, particularly if it's
a very weird boundary - but you can remedy this by taking more samples
and repeating the process, sometimes from different spots.)
</p>

<p>
To put it in more technical terms: You just traced out the <b>distance
surface</b> that a <b>distance function</b> (or a distance field) described
implicitly. If this sounds like it's related to the mention of
<b>isolines</b> in the last section, it's because it is.
</p>
</div>

<div id="outline-container-orgb7d955c" class="outline-3">
<h3 id="orgb7d955c"><span class="section-number-3"> 3.1</span> Distance Functions</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In that thought experiment, the hypothetical GPS was providing a
<b>distance function</b> which maps every point in 2D space to a
nearest-distance value.  Put another way, that distance function is
providing, for any given point, the radius of the largest possible
circle (centered at that point) which does <b>not</b> intersect that
boundary.
</p>

<p>
This works identically in 3 dimensions.  The only change is that it is
giving the radius of the largest sphere, not the largest circle, and
it is implicitly describing an entire 3D surface, not just a 2D
boundary.
</p>

<p>
Interestingly enough, the above method still works if the GPS behaves
a little more strangely: it doesn't need to tell you the exact
distance; it could simply tell you some (non-zero) distance for which
you're guaranteed <b>not</b> to hit the boundary in any direction.
</p>
</div>
</div>

<div id="outline-container-org0ffdd75" class="outline-3">
<h3 id="org0ffdd75"><span class="section-number-3"> 3.2</span> Sphere Tracing</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Using a very similar process as in the thought experiment above, this
distance function can be used to trace out 3D surfaces seen from some
point - in other words, to render them in 3D.  This can be done with
<b>sphere tracing</b>, an algorithm that performs a very similar process
pixel-by-pixel.  It is similar to <a target='_blank' href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracing</a>; it is technically a
method of ray marching.
</p>

<p>
Below is an example of rendering a cube in 3D this way.  Don't worry
too much about <code>main()</code>; this code is just there to set up the
renderer, which is a little more complicated in 3D.  Focus on
<code>distance()</code> - this is the distance function that is actually being
rendered, and it's called indirectly via <code>render</code>.
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-1' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;

float distance(in vec3 pos)
{
    return length(max(abs(pos) - 1.0, 0.0));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-1' style='display:none'>/* PARAMETERS
[
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;

float distance(in vec3 pos)
{
    return length(max(abs(pos) - 1.0, 0.0));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-1').text());">Use code &raquo;</button></div>
</div>

<p>
You can drag the view around with the mouse.  You're now looking at a
3D coordinate system, not a 2D one; the X and Z axes are the ground
(so to speak), and the Y axis is up.
</p>

<p>
To explain why <code>distance</code> works, it may help to expand the rather
terse equation a little; <code>max</code> and <code>abs</code> are both element-wise, while
<code>length</code> is over the entire vector.  If \(d(p)\) stands for
<code>distance(pos)</code>:
</p>

\begin{equation}
d(p)=\sqrt{\max(|p_x|-1,0)^2+\max(|p_y|-1,0)^2+\max(|p_z|-1,0)^2}
\end{equation}
</div>
</div>

<div id="outline-container-org0cf8ed3" class="outline-3">
<h3 id="org0cf8ed3"><span class="section-number-3"> 3.3</span> Blah blah blah</h3>
<div class="outline-text-3" id="text-1-3">
<p>
If \(a^2=b\) and \( b=2 \), then the solution must be
either \[ a=+\sqrt{2} \] or \[ a=-\sqrt{2} \].
</p>

\begin{equation}
x=\sqrt{b}
\end{equation}
</div>
</div>

<div id="outline-container-orgc4d731d" class="outline-3">
<h3 id="orgc4d731d"><span class="section-number-3"> 3.4</span> Single sphere</h3>
<div class="outline-text-3" id="text-1-4">
<p>
If you look more closely at <code>distance</code> you might note that the
distance function will return negative values <b>inside</b> the sphere.
This is intentional; we now have a <a target='_blank' href="https://en.wikipedia.org/wiki/Signed_distance_function">signed distance function</a>.  It's a
fairly small change: The 3D surface must have a clear inside and
outside, and the signed distance function returns a positive number
for any point <b>outside</b> that surface and a negative number for any
point <b>inside</b> that surface.  It's otherwise the same.
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-2' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float radius;

float distance(in vec3 pos)
{
    return length(pos) - radius;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-2' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1,
       "min": 0,
       "max": 10,
       "name": "radius",
       "GUIName": "Radius"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float radius;

float distance(in vec3 pos)
{
    return length(pos) - radius;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-2').text());">Use code &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org0b40af9" class="outline-3">
<h3 id="org0b40af9"><span class="section-number-3"> 3.5</span> Repeated cubes 1</h3>
<div class="outline-text-3" id="text-1-5">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-3' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float freq;
uniform float freq2;

float distance(in vec3 pos)
{
    vec3 pos_ = vec3(mod(pos.x, 2.0) - 1.0, pos.y, mod(pos.z, 2.0) - 1.0);
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);
    float res = min(sdPlane(pos),
                    udRoundBox(pos3-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
	float time = 15.0 + time;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-3' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 0.1,
       "min": -5,
       "max": 5,
       "name": "freq",
       "GUIName": "Freq"
   },
   {
       "type": "float",
       "value": 0.1,
       "min": -1,
       "max": 1,
       "name": "freq2",
       "GUIName": "Freq2"
   }   
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float freq;
uniform float freq2;

float distance(in vec3 pos)
{
    vec3 pos_ = vec3(mod(pos.x, 2.0) - 1.0, pos.y, mod(pos.z, 2.0) - 1.0);
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);
    float res = min(sdPlane(pos),
                    udRoundBox(pos3-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
	float time = 15.0 + time;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-3').text());">Use code &raquo;</button></div>
</div>
</div>
</div>


<div id="outline-container-org7b8b23a" class="outline-3">
<h3 id="org7b8b23a"><span class="section-number-3"> 3.6</span> Repeated cubes 2</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-4' mode="ace/mode/glsl" readonly="true">
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float dx;
uniform float dz;

float distance(in vec3 pos)
{
    float ca_d = cos(0.05 * length(pos) + time*0.1);
    float sa_d = sin(0.05 * length(pos) + time*0.1);
    vec3 pos_ = pos;
    pos_ = vec3(pos_.x * ca_d - pos_.y * sa_d, pos_.x * sa_d + pos_.y * ca_d, pos_.z);
    
    float ca_d2 = cos(0.05 * length(pos) + time*0.2);
    float sa_d2 = sin(0.05 * length(pos) + time*0.2);
    //pos_ = vec3(pos_.x, pos_.y * ca_d2 - pos_.z * sa_d2, pos_.y * sa_d2 + pos_.z * ca_d2);

    pos_ = vec3(mod(pos_.x, dx) - dx/2.0, pos_.y, mod(pos_.z, dz) - dz/2.0);
    /*
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);*/
    float res = udRoundBox(pos_-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05);
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-4' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 2,
       "min": 1,
       "max": 10,
       "name": "dx",
       "GUIName": "dx"
   },
   {
       "type": "float",
       "value": 2,
       "min": 1,
       "max": 10,
       "name": "dz",
       "GUIName": "dz"
   }   
]
END */

#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float dx;
uniform float dz;

float distance(in vec3 pos)
{
    float ca_d = cos(0.05 * length(pos) + time*0.1);
    float sa_d = sin(0.05 * length(pos) + time*0.1);
    vec3 pos_ = pos;
    pos_ = vec3(pos_.x * ca_d - pos_.y * sa_d, pos_.x * sa_d + pos_.y * ca_d, pos_.z);
    
    float ca_d2 = cos(0.05 * length(pos) + time*0.2);
    float sa_d2 = sin(0.05 * length(pos) + time*0.2);
    //pos_ = vec3(pos_.x, pos_.y * ca_d2 - pos_.z * sa_d2, pos_.y * sa_d2 + pos_.z * ca_d2);

    pos_ = vec3(mod(pos_.x, dx) - dx/2.0, pos_.y, mod(pos_.z, dz) - dz/2.0);
    /*
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);*/
    float res = udRoundBox(pos_-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05);
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-4').text());">Use code &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgf8134c5" class="outline-3">
<h3 id="orgf8134c5"><span class="section-number-3"> 3.7</span> Repeated cubes 3</h3>
<div class="outline-text-3" id="text-1-7">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-5' mode="ace/mode/glsl" readonly="true">
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float dist;

float distance(in vec3 pos)
{
    vec3 pos_ = mod(pos, dist) - dist/2.0;
    float res = sdBox(pos_, vec3(0.5));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-5' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 2,
       "min": 1,
       "max": 10,
       "name": "dist",
       "GUIName": "Dist"
   }   
]
END */

#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float dist;

float distance(in vec3 pos)
{
    vec3 pos_ = mod(pos, dist) - dist/2.0;
    float res = sdBox(pos_, vec3(0.5));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-5').text());">Use code &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgfbbe343" class="outline-3">
<h3 id="orgfbbe343"><span class="section-number-3"> 3.8</span> Distance Bounds &amp; Distance Fields</h3>
<div class="outline-text-3" id="text-1-8">
</div><div id="outline-container-org14bf530" class="outline-4">
<h4 id="org14bf530"><span class="section-number-4"> 3.8.1</span> Why a sphere tracer?</h4>
</div>
</div>

<div id="outline-container-orgc65c4d6" class="outline-3">
<h3 id="orgc65c4d6"><span class="section-number-3"> 3.9</span> Transformations</h3>
<div class="outline-text-3" id="text-1-9">
</div>

<div id="outline-container-org72d6042" class="outline-4">
<h4 id="org72d6042"><span class="section-number-4"> 3.9.1</span> Scaling</h4>
</div>

<div id="outline-container-org984ed90" class="outline-4">
<h4 id="org984ed90"><span class="section-number-4"> 3.9.2</span> Translation</h4>
</div>

<div id="outline-container-org1333a2e" class="outline-4">
<h4 id="org1333a2e"><span class="section-number-4"> 3.9.3</span> Rotation</h4>
</div>

<div id="outline-container-org1928133" class="outline-4">
<h4 id="org1928133"><span class="section-number-4"> 3.9.4</span> Shearing</h4>
</div>

<div id="outline-container-org63bacd2" class="outline-4">
<h4 id="org63bacd2"><span class="section-number-4"> 3.9.5</span> Vectors &amp; Matrices</h4>
<div class="outline-text-4" id="text-1-9-5">
</div>
</div>
</div>

<div id="outline-container-org70be815" class="outline-3">
<h3 id="org70be815"><span class="section-number-3"> 3.10</span> Constructive Solid Geometry</h3>
</div>

<div id="outline-container-orgf8aa129" class="outline-3">
<h3 id="orgf8aa129"><span class="section-number-3"> 3.11</span> Domain Warping</h3>
</div>

<div id="outline-container-org4356911" class="outline-3">
<h3 id="org4356911"><span class="section-number-3"> 3.12</span> Domain Repetition</h3>
</div>

<div id="outline-container-orge705879" class="outline-3">
<h3 id="orge705879"><span class="section-number-3"> 3.13</span> Summary</h3>
<div class="outline-text-3" id="text-1-13">
<p>
This concludes the tutorial - at least, until I write more.  The <a href="#" onclick="myModule.loadTutorial('./04_Final_Notes.html', null)">next
section</a> contains some other references that you may wish to read.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
