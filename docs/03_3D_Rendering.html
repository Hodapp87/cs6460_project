<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-07-18 Tue 12:32 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Rendering</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Chris Hodapp" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.20/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">3D Rendering</h1>

<div id="outline-container-org742ea3c" class="outline-2">
<h2 id="org742ea3c"><span class="section-number-2"> 3</span> 3D Rendering</h2>
<div class="outline-text-2" id="text-1">
<p>
In the last chapter, we dealt with a class of functions which mapped
2D space (i.e. a pixel location) to color values.  In this chapter, we
generalize this a bit, and deal with functions that map 3D space to
something.
</p>

<p>
First, though, consider a (far-fetched) thought experiment.  Suppose
you're outside and you need to trace out some strange geographical
boundary - maybe an irregular, invisible property line.  For whatever
reason, you don't even have a map.  What you do have is a precise but
rather strange GPS device&#x2026; and all it can do is tell you, whenever
you need, the shortest distance you could move in order to reach the
nearest part of that boundary.  It doesn't tell you which direction.
If it tells you "21 feet", all it means is that in some direction, the
boundary is exactly 21 feet away, and it's not closer than that in any
other direction.
</p>

<p>
Assume you have some other basic implements, like a tape measure and a
can of spray paint, and assume that you at least know you're starting
somewhere inside this boundary.  Now, how could you go about finding
and marking this boundary (or something fairly close to it)?
</p>

<p>
There are probably many different answers, but here is one method to
consider:
</p>

<ol class="org-ol">
<li>Mark your starting point on the ground.</li>
<li>Pick any direction.</li>
<li>Get the nearest-distance measurement from the GPS.</li>
<li>Walk in a straight line in the chosen direction until you've
covered the distance the GPS told you.</li>
<li>Go back to step 3, using the same direction. Once the GPS gives
distance measurements that are very small (e.g. one inch), stop.</li>
<li>Wherever you are, make a marking on the ground.</li>
<li>Return to your starting point.</li>
<li>Pick a new direction, rotated very slightly from the last time
(e.g. just 1/2 degree clockwise).</li>
<li>Repeat step 3.  Once you've returned to your starting direction,
stop.</li>
</ol>

<p>
This is very pain-staking and tedious - but the end result is that
you've marked off the entire boundary, at 1/2 degree increments, to
within an inch. (It's possible you'll miss spots, particularly if it's
a very weird boundary - but you can remedy this by taking more samples
and repeating the process, sometimes from different spots.)
</p>

<p>
To put it in more technical terms: You just traced out the <b>distance
surface</b> that a <b>distance function</b> (or a distance field) described
implicitly. If this sounds like it's related to the mention of
<b>isolines</b> in the last chapter, it's because it is.
</p>
</div>

<div id="outline-container-orgc8f8f16" class="outline-3">
<h3 id="orgc8f8f16"><span class="section-number-3"> 3.1</span> Distance Functions</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In that thought experiment, the hypothetical GPS was providing a
<b>distance function</b> which maps every point in 2D space to a
nearest-distance value.  Put another way, that distance function is
providing, for any given point, the radius of the largest possible
circle (centered at that point) which does <b>not</b> intersect that
boundary.
</p>

<p>
This works identically in 3 dimensions.  The only change is that it is
giving the radius of the largest sphere, not the largest circle, and
it is implicitly describing an entire 3D surface, not just a 2D
boundary.
</p>

<p>
Interestingly enough, the above method still works if the GPS behaves
a little more strangely: it doesn't need to tell you the exact
distance; it could simply tell you some (non-zero) distance for which
you're guaranteed <b>not</b> to hit the boundary in any direction.
</p>
</div>
</div>

<div id="outline-container-org371e093" class="outline-3">
<h3 id="org371e093"><span class="section-number-3"> 3.2</span> Sphere Tracing</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Using a very similar process as in the thought experiment above, this
distance function can be used to trace out 3D surfaces seen from some
point - in other words, to render them in 3D.  This can be done with
<b>sphere tracing</b>, an algorithm that performs a very similar process
pixel-by-pixel.  It is similar to <a target='_blank' href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracing</a>; it is technically a
method of ray marching.
</p>

<p>
Below is an example of rendering a cube in 3D this way.  Don't worry
too much about <code>main()</code>; this code is just there to set up the
renderer, which is a little more complicated in 3D.  Focus on
<code>distance()</code> - this is the distance function that is actually being
rendered, and it's called indirectly via <code>render</code>.
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-1' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;

float distance(in vec3 pos)
{
    return length(max(abs(pos) - 1.0, 0.0));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-1' style='display:none'>/* PARAMETERS
[
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;

float distance(in vec3 pos)
{
    return length(max(abs(pos) - 1.0, 0.0));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-1').text());">Use code &raquo;</button></div>
</div>

<p>
You can drag the view around with the mouse.  You're now looking at a
3D coordinate system, not a 2D one; the X and Z axes are the ground
(so to speak), and the Y axis is up.  In this case the mouse is
dragging around the camera's position, not the coordinate system
itself.
</p>

<p>
To explain why <code>distance</code> works, it may help to expand the rather
terse equation a little; <code>max</code> and <code>abs</code> are both element-wise, while
<code>length</code> is over the entire vector.  If \(d(p)\) stands for
<code>distance(pos)</code>:
</p>

\begin{equation}
d(p)=\sqrt{\max(|p_x|-1,0)^2+\max(|p_y|-1,0)^2+\max(|p_z|-1,0)^2}
\end{equation}

<p>
Mentally try a few values of \(p_x\) in \(\max(|p_x|-1,0)\).  Note that
for \(-1 \leq p_x \leq 1\), it is zero, while picking a value of
\(p_x<-1\) gives the distance in the \(x\) axis to -1 and picking a value
of \(p_x>1\) gives the distance in the \(x\) axis to 1.  It behaves
identically for \(p_y\) and the \(y\) axis, and \(p_z\) and the \(z\) axis.
The final result is just applying the distance formula to these three
values, thus giving the total distance from the region \(-1 \leq p_x
\leq 1\), \(-1 \leq p_y \leq 1\), and \(-1 \leq p_z \leq 1\) - which is a
cube of sidelength 2, centered at \((0,0,0)\).
</p>
</div>
</div>

<div id="outline-container-org8a2a46b" class="outline-3">
<h3 id="org8a2a46b"><span class="section-number-3"> 3.3</span> Transformations</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<a href="#" onclick="myModule.loadTutorial('./02_2D_Coordinates.html', null)">Chapter 2</a> discussed how we could change something by transforming the
2D coordinate space it's in.  We can do that identically with the 3D
coordinate space here.  See the example below, and note that the only
thing we've done is replace \(d(p)\) with \(\frac{d(sp)}{s}\), where \(s\) is
a new parameter just added.
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-2' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float s;

float distance(in vec3 pos)
{
    return length(max(abs(pos * s) - 1.0, 0.0)) / s;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-2' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1,
       "min": 0,
       "max": 5,
       "name": "s",
       "GUIName": "s"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float s;

float distance(in vec3 pos)
{
    return length(max(abs(pos * s) - 1.0, 0.0)) / s;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-2').text());">Use code &raquo;</button></div>
</div>

<p>
Adjust the parameter's value, and the effect may be the inverse of
what you would expect.  To make sense of this, consider that by
multiplying <code>pos</code> by a value &gt; 1, you are scaling up the entire
space - but the cube still has a constant sidelength of 2.  (Dividing
the length by \(s\) is a correction that is only needed because
<code>distance()</code> returns a length that must be in our "original" space,
not our new scaled space - but scaling changes this length.)
</p>

<p>
Predictably, some other basic motions are easy too.  The code below
adds 3 parameters, \(tx\), \(ty\), and \(tz\), and subtracts these from the
location before applying the scaling of the last step:
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-3' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float s;
uniform float tx;
uniform float ty;
uniform float tz;

float distance(in vec3 pos)
{
    vec3 pos2 = pos - vec3(tx, ty, tz);
    return length(max(abs(pos2 * s).xyz - 1.0, 0.0)) / s;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-3' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1,
       "min": 0,
       "max": 5,
       "name": "s",
       "GUIName": "s"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "tx",
       "GUIName": "tx"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "ty",
       "GUIName": "ty"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "tz",
       "GUIName": "tz"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float s;
uniform float tx;
uniform float ty;
uniform float tz;

float distance(in vec3 pos)
{
    vec3 pos2 = pos - vec3(tx, ty, tz);
    return length(max(abs(pos2 * s).xyz - 1.0, 0.0)) / s;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-3').text());">Use code &raquo;</button></div>
</div>

<p>
Similar intuition applies here: In subtracting \((t_x, t_y, t_z)\) we
are shifting (or translating) the entire space so that the coordinates
\((t_x, t_y, t_z)\) are the new origin of the space.  Note that the
scaling is done <b>after</b> the translation; the order matters here.
Scale and translate in the opposite order to see why.
</p>
</div>
</div>

<div id="outline-container-org992fad5" class="outline-3">
<h3 id="org992fad5"><span class="section-number-3"> 3.4</span> Matrices</h3>
<div class="outline-text-3" id="text-1-4">
<p>
While scaling and translating are simple enough operations to do
manually with multiplications and subtractions, other transformations
can become unruly when expressed this way.
</p>

<p>
Fortunately, WebGL and GLSL provide support for matrices.  The
following matrix will rotate around the \(x\) axis, for instance:
</p>

\begin{bmatrix}
  1 & 0 & 0 & 0 \\
  0 & \cos\theta & -\sin\theta & 0 \\
  0 & \sin\theta & \cos\theta & 0 \\
  0 & 0 & 0 & 1
\end{bmatrix}

<p>
WebGL treats the <code>vec4</code> like a 4x1 matrix (i.e. a column vector), and
so the <code>pos_h * rot</code> in the below code is computed as:
</p>

\begin{equation}
\begin{bmatrix}
  p_x \\ p_y \\ p_z \\ 1
\end{bmatrix}
\begin{bmatrix}
  1 & 0 & 0 & 0 \\
  0 & \cos\theta & -\sin\theta & 0 \\
  0 & \sin\theta & \cos\theta & 0 \\
  0 & 0 & 0 & 1
\end{bmatrix} = 
\begin{bmatrix}
  p_x \\ p_y\cos\theta - p_z\sin\theta \\ p_y\sin\theta + p_z\cos\theta \\ 1
\end{bmatrix}
\end{equation}

<p>
The below code uses this (note that we multiply the position by the
matrix). 
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-4' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float rx;

float distance(in vec3 pos)
{
    vec4 pos_h = vec4(pos, 1.0);
    mat4 rot = mat4(1, 0,        0,       0,
                    0, cos(rx), -sin(rx), 0,
                    0, sin(rx),  cos(rx), 0,
                    0, 0,        0,       1);
    return length(max(abs(pos_h * rot) - 1.0, 0.0));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-4' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 0,
       "min": -3.14,
       "max": 3.14,
       "name": "rx",
       "GUIName": "rx"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float rx;

float distance(in vec3 pos)
{
    vec4 pos_h = vec4(pos, 1.0);
    mat4 rot = mat4(1, 0,        0,       0,
                    0, cos(rx), -sin(rx), 0,
                    0, sin(rx),  cos(rx), 0,
                    0, 0,        0,       1);
    return length(max(abs(pos_h * rot) - 1.0, 0.0));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-4').text());">Use code &raquo;</button></div>
</div>

<p>
We have to turn the <code>vec3</code> position into a <code>vec4</code> and then use <code>.xyz</code>
to return it to a <code>vec3</code> for reasons that will be explained shortly.
</p>

<p>
Of course, we can express the scale as a transformation matrix as
well:
</p>

\begin{bmatrix}
  s & 0 & 0 & 0 \\
  0 & s & 0 & 0 \\
  0 & 0 & s & 0 \\
  0 & 0 & 0 & 1
\end{bmatrix}

<p>
And the translation:
</p>

\begin{bmatrix}
  1 & 0 & 0 & -t_x \\
  0 & 1 & 0 & -t_y \\
  0 & 0 & 1 & -t_z \\
  0 & 0 & 0 & 1
\end{bmatrix}

<p>
This is used below. They're purposely chained in a particular order:
the position is first translated (translation is done in the
"original" space), then everything is scaled (scaling is relative to
the new, translated origin), then everything is rotated (again,
relative to the new, translated origin).
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-5' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float s;
uniform float tx;
uniform float ty;
uniform float tz;
uniform float rx;

float distance(in vec3 pos)
{
    vec4 pos_h = vec4(pos, 1.0);
    mat4 rot = mat4(1, 0,        0,       0,
                    0, cos(rx), -sin(rx), 0,
                    0, sin(rx),  cos(rx), 0,
                    0, 0,        0,       1);
    mat4 trans = mat4(1, 0, 0, -tx,
                      0, 1, 0, -ty,
                      0, 0, 1, -tz,
                      0, 0, 0, 1);
    mat4 scale = mat4(s, 0, 0, 0,
                      0, s, 0, 0,
                      0, 0, s, 0,
                      0, 0, 0, 1);
    return length(max(abs(pos_h * trans * scale * rot).xyz - 1.0, 0.0)) / s;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-5' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1,
       "min": 0,
       "max": 5,
       "name": "s",
       "GUIName": "s"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "tx",
       "GUIName": "tx"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "ty",
       "GUIName": "ty"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "tz",
       "GUIName": "tz"
   },
   {
       "type": "float",
       "value": 0,
       "min": -3.14,
       "max": 3.14,
       "name": "rx",
       "GUIName": "rx"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float s;
uniform float tx;
uniform float ty;
uniform float tz;
uniform float rx;

float distance(in vec3 pos)
{
    vec4 pos_h = vec4(pos, 1.0);
    mat4 rot = mat4(1, 0,        0,       0,
                    0, cos(rx), -sin(rx), 0,
                    0, sin(rx),  cos(rx), 0,
                    0, 0,        0,       1);
    mat4 trans = mat4(1, 0, 0, -tx,
                      0, 1, 0, -ty,
                      0, 0, 1, -tz,
                      0, 0, 0, 1);
    mat4 scale = mat4(s, 0, 0, 0,
                      0, s, 0, 0,
                      0, 0, s, 0,
                      0, 0, 0, 1);
    return length(max(abs(pos_h * trans * scale * rot).xyz - 1.0, 0.0)) / s;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-5').text());">Use code &raquo;</button></div>
</div>

<p>
This looks like a lot of extra notation, but part of the point comes
about because a series of matrix multiplications like \(pTSR_x\) - like
we are doing above for position \(p\), translation matrix \(T\), scaling
matrix \(S\), and rotation matrix \(R_x\) - can be rewritten like
\(p(TSR_x)\), that is, the three transformation matrices can be
multiplied into a single 4x4 matrix.  This is trivial to do in the
code (and the below should render completely identically):
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-6' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float s;
uniform float tx;
uniform float ty;
uniform float tz;
uniform float rx;

float distance(in vec3 pos)
{
    vec4 pos_h = vec4(pos, 1.0);
    mat4 rot = mat4(1, 0,        0,       0,
                    0, cos(rx), -sin(rx), 0,
                    0, sin(rx),  cos(rx), 0,
                    0, 0,        0,       1);
    mat4 trans = mat4(1, 0, 0, -tx,
                      0, 1, 0, -ty,
                      0, 0, 1, -tz,
                      0, 0, 0, 1);
    mat4 scale = mat4(s, 0, 0, 0,
                      0, s, 0, 0,
                      0, 0, s, 0,
                      0, 0, 0, 1);
    mat4 t = trans * scale * rot;
    return length(max(abs(pos_h * t).xyz - 1.0, 0.0)) / s;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-6' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1,
       "min": 0,
       "max": 5,
       "name": "s",
       "GUIName": "s"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "tx",
       "GUIName": "tx"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "ty",
       "GUIName": "ty"
   },
   {
       "type": "float",
       "value": 0,
       "min": -5,
       "max": 5,
       "name": "tz",
       "GUIName": "tz"
   },
   {
       "type": "float",
       "value": 0,
       "min": -3.14,
       "max": 3.14,
       "name": "rx",
       "GUIName": "rx"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float s;
uniform float tx;
uniform float ty;
uniform float tz;
uniform float rx;

float distance(in vec3 pos)
{
    vec4 pos_h = vec4(pos, 1.0);
    mat4 rot = mat4(1, 0,        0,       0,
                    0, cos(rx), -sin(rx), 0,
                    0, sin(rx),  cos(rx), 0,
                    0, 0,        0,       1);
    mat4 trans = mat4(1, 0, 0, -tx,
                      0, 1, 0, -ty,
                      0, 0, 1, -tz,
                      0, 0, 0, 1);
    mat4 scale = mat4(s, 0, 0, 0,
                      0, s, 0, 0,
                      0, 0, s, 0,
                      0, 0, 0, 1);
    mat4 t = trans * scale * rot;
    return length(max(abs(pos_h * t).xyz - 1.0, 0.0)) / s;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-6').text());">Use code &raquo;</button></div>
</div>

<p>
If you recall the part in chapter 2 on composition of functions, we
are doing exactly the same thing here.  It just happens that the
functions we're composing are mostly matrix multiplications, and
matrix multiplications behave in some helpful ways (e.g. they are
<a target='_blank' href="https://en.wikipedia.org/wiki/Matrix_multiplication#Properties_of_the_matrix_product_.28any_number_of_matrices_in_the_product.29">associative</a>).
</p>
</div>
</div>

<div id="outline-container-org7436f8d" class="outline-3">
<h3 id="org7436f8d"><span class="section-number-3"> 3.5</span> Homogeneous coordinates</h3>
<div class="outline-text-3" id="text-1-5">
<p>
It may seem a bit strange that we are working with a 3-element vector,
adding in a 4th element (which is always 1), multiplying this by a 4x4
matrix, and then discarding the 4th element.  With scaling and
rotating (and a few other things), this isn't actually necessary.  We
have used this 3x3 matrix for rotating, and multiplied a <code>vec3</code> by it:
</p>

\begin{bmatrix}
  1 & 0 & 0 \\
  0 & \cos\theta & -\sin\theta \\
  0 & \sin\theta & \cos\theta \\
\end{bmatrix}

<p>
One benefit of this form is that we can interpret it as a <a target='_blank' href="https://en.wikipedia.org/wiki/Change_of_basis">change of
basis</a> matrix.  If our <b>basis</b> here is three unit vectors,
\(\hat{x}=(1,0,0)\), \(\hat{y}=(0,1,0)\), \(\hat{z}=(0,0,1)\) (which are
just the \(x\), \(y\) and \(z\) axis), we can look at the above 3x3 matrix,
or any other 3x3 transformation matrix, as three new vectors, one
for each row of the matrix:
</p>

\begin{bmatrix}
  \hat{x}' \\ \hat{y}' \\ \hat{z}'
\end{bmatrix}

<p>
where \(\hat{x}'\) is the result of transforming \(\hat{x}\), \(\hat{y}'\)
the result of transforming \(\hat{y}\), and \(\hat{z}'\) the result of
transforming \(\hat{z}\).  In other words, that matrix contains our
"new" \(x\) axis, \(y\) axis, and \(z\) axis.  This makes some intuitive
sense if we look at the matrix above which rotates around the \(x\) axis
by \(\theta\): the \(x\) axis stays untouched, but the \(y\) and \(z\) axis
rotate.  Similar intuition applies to a scaling matrix: all it does is
stretch or compress the axes.  Likewise, it means that if we leave the
axes alone, we have the normal 3x3 identity matrix:
</p>

\begin{bmatrix}
  1 & 0 & 0 \\
  0 & 1 & 0 \\
  0 & 0 & 1 \\
\end{bmatrix}

<p>
However, a little effort will reveal that the third transformation we
examined - a translation - cannot be expressed this way.  In short: We
add the extra coordinate (that is, make it <a target='_blank' href="https://en.wikipedia.org/wiki/Homogeneous_coordinates#Use_in_computer_graphics">homogeneous</a>) as a way to
let us express translations in matrix form (and <a target='_blank' href="https://en.wikipedia.org/wiki/Affine_transformation">affine transformations</a>
in general - including the all-important projective transformation
used anytime a 3D render includes perspective).
</p>

<p>
The transformations given above are rather uninteresting, but
well-studied, well-behaved, efficient to compute, and essential to 3D
graphics in general.
</p>
</div>
</div>

<div id="outline-container-org38c2970" class="outline-3">
<h3 id="org38c2970"><span class="section-number-3"> 3.6</span> Rotations</h3>
<div class="outline-text-3" id="text-1-6">
<p>
So far we've only shown rotation in the \(x\) axis.  It appears
straightforward to extend this rotation in \(x\), in \(y\), and \(z\)
(i.e. <a target='_blank' href="https://en.wikipedia.org/wiki/Euler_angles">Euler angles</a>).  The below tries this, illustrating the three
axes with thin rectangles:
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-7' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float rx;
uniform float ry;
uniform float rz;

float distance(in vec3 pos)
{
    mat3 rotx = mat3(1, 0,        0,      
                     0, cos(rx), -sin(rx),
                     0, sin(rx),  cos(rx));
    mat3 roty = mat3(cos(ry), 0, -sin(ry),
                     0,       1, 0,      
                     sin(ry), 0, cos(ry));
    mat3 rotz = mat3(cos(rz), -sin(rz), 0,
                     sin(rz),  cos(rz), 0,
                     0,       0,        1);
    mat3 t = rotx * roty * rotz;

    vec3 offset = vec3(5.0, 0.1, 0.1);
    float x_axis = length(max(abs((pos * t - offset.xyz)) - offset.xyz, 0.0));
    float y_axis = length(max(abs((pos * t - offset.yxz)) - offset.yxz, 0.0));
    float z_axis = length(max(abs((pos * t - offset.yzx)) - offset.yzx, 0.0));
    return min(x_axis, min(y_axis, z_axis));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-7' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 0,
       "min": -3.14,
       "max": 3.14,
       "name": "rx",
       "GUIName": "rx"
   },
   {
       "type": "float",
       "value": 0,
       "min": -3.14,
       "max": 3.14,
       "name": "ry",
       "GUIName": "ry"
   },
   {
       "type": "float",
       "value": 0,
       "min": -3.14,
       "max": 3.14,
       "name": "rz",
       "GUIName": "rz"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float rx;
uniform float ry;
uniform float rz;

float distance(in vec3 pos)
{
    mat3 rotx = mat3(1, 0,        0,      
                     0, cos(rx), -sin(rx),
                     0, sin(rx),  cos(rx));
    mat3 roty = mat3(cos(ry), 0, -sin(ry),
                     0,       1, 0,      
                     sin(ry), 0, cos(ry));
    mat3 rotz = mat3(cos(rz), -sin(rz), 0,
                     sin(rz),  cos(rz), 0,
                     0,       0,        1);
    mat3 t = rotx * roty * rotz;

    vec3 offset = vec3(5.0, 0.1, 0.1);
    float x_axis = length(max(abs((pos * t - offset.xyz)) - offset.xyz, 0.0));
    float y_axis = length(max(abs((pos * t - offset.yxz)) - offset.yxz, 0.0));
    float z_axis = length(max(abs((pos * t - offset.yzx)) - offset.yzx, 0.0));
    return min(x_axis, min(y_axis, z_axis));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-7').text());">Use code &raquo;</button></div>
</div>

<p>
(This also demonstrates a WebGL feature called <b>swizzling</b>: We may
access a vector's elements in any order, and this is why <code>y_axis</code> and
<code>z_axis</code> access <code>offset</code> as <code>offset.yxz</code> and <code>offset.yzx</code>,
respectively - it rearranges the coordinates in <code>offset</code>.)
</p>

<p>
However, to see some problems with this, try adjusting the slider for
<code>ry</code> to about 1.57 or -1.57 (that is, \(\pm\frac{\pi}{2}\)), and then
adjust <code>rx</code> and <code>rz</code>.  No matter how you move the other two, you will
see that they are now moving in the same axis; in effect, you have
lost an axis until you move <code>ry</code> to something else.  This is an
illustration of <a target='_blank' href="https://en.wikipedia.org/wiki/Gimbal_lock">gimbal lock</a>, and any representation of rotation in 3D
that relies on three angles is susceptible to it.
</p>

<p>
One alternative to this is <a target='_blank' href="https://en.wikipedia.org/wiki/Quaternion">quaternions</a>:
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-8' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;
uniform float a_, b_, c_, d_;

float distance(in vec3 pos)
{
    vec4 q = vec4(a_, b_, c_, d_);
    q = q / length(q);

    // Interpolation:
    // q = mix(vec4(1.0, 0.0, 0.0, 0.0), q, sin(time * 0.01) * 0.5 + 0.5);

    float a = q.x, b = q.y, c = q.z, d = q.w;
    mat3 t = mat3(a*a + b*b - c*c - d*d, 2.0*b*c - 2.0*a*d,     2.0*b*d + 2.0*a*c,
                  2.0*b*c + 2.0*a*d,     a*a - b*b + c*c - d*d, 2.0*c*d - 2.0*a*b,
                  2.0*b*d - 2.0*a*c,     2.0*c*d + 2.0*a*b,     a*a - b*b - c*c + d*d);

    vec3 offset = vec3(5.0, 0.1, 0.1);
    float x_axis = length(max(abs((pos * t - offset.xyz)) - offset.xyz, 0.0));
    float y_axis = length(max(abs((pos * t - offset.yxz)) - offset.yxz, 0.0));
    float z_axis = length(max(abs((pos * t - offset.yzx)) - offset.yzx, 0.0));
    return min(x_axis, min(y_axis, z_axis));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-8' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1,
       "min": -1,
       "max": 1,
       "name": "a_",
       "GUIName": "a"
   },
   {
       "type": "float",
       "value": 0,
       "min": -1,
       "max": 1,
       "name": "b_",
       "GUIName": "b"
   },
   {
       "type": "float",
       "value": 0,
       "min": -1,
       "max": 1,
       "name": "c_",
       "GUIName": "c"
   },
   {
       "type": "float",
       "value": 0,
       "min": -1,
       "max": 1,
       "name": "d_",
       "GUIName": "d"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;
uniform float a_, b_, c_, d_;

float distance(in vec3 pos)
{
    vec4 q = vec4(a_, b_, c_, d_);
    q = q / length(q);

    // Interpolation:
    // q = mix(vec4(1.0, 0.0, 0.0, 0.0), q, sin(time * 0.01) * 0.5 + 0.5);

    float a = q.x, b = q.y, c = q.z, d = q.w;
    mat3 t = mat3(a*a + b*b - c*c - d*d, 2.0*b*c - 2.0*a*d,     2.0*b*d + 2.0*a*c,
                  2.0*b*c + 2.0*a*d,     a*a - b*b + c*c - d*d, 2.0*c*d - 2.0*a*b,
                  2.0*b*d - 2.0*a*c,     2.0*c*d + 2.0*a*b,     a*a - b*b - c*c + d*d);

    vec3 offset = vec3(5.0, 0.1, 0.1);
    float x_axis = length(max(abs((pos * t - offset.xyz)) - offset.xyz, 0.0));
    float y_axis = length(max(abs((pos * t - offset.yxz)) - offset.yxz, 0.0));
    float z_axis = length(max(abs((pos * t - offset.yzx)) - offset.yzx, 0.0));
    return min(x_axis, min(y_axis, z_axis));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(0.0, 0.0, 0.0);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-8').text());">Use code &raquo;</button></div>
</div>

<p>
It is less intuitive than Euler angles, but retains some benefits.  To
see one, uncomment the line below the <code>// Interpolation</code> comment in
the <code>distance()</code> function, and enable animation; this shows the
ability to linearly interpolate between rotations in two quaternions.
</p>
</div>
</div>

<div id="outline-container-org8e8f378" class="outline-3">
<h3 id="org8e8f378"><span class="section-number-3"> 3.7</span> More on distance functions</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-org7e23e8b" class="outline-4">
<h4 id="org7e23e8b"><span class="section-number-4"> 3.7.1</span> Primitives</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
Cubes are likewise rather boring by themselves, even if we can use
matrices to move them around.  However, distance functions can
represent a variety of other shapes.  One very simple one is a sphere:
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-9' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;

float distance(in vec3 pos)
{
    return length(pos) - 1.0;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-9' style='display:none'>/* PARAMETERS
[
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;

float distance(in vec3 pos)
{
    return length(pos) - 1.0;
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-9').text());">Use code &raquo;</button></div>
</div>

<p>
See Íñigo Quílez's page <a target='_blank' href="http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">Modeling with Distance Functions</a> for a list of
many others.
</p>
</div>
</div>

<div id="outline-container-org6e73fe7" class="outline-4">
<h4 id="org6e73fe7"><span class="section-number-4"> 3.7.2</span> Constructive Solid Geometry</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
Distance functions are also rather easy to combine in the methods of
<a target='_blank' href="https://en.wikipedia.org/wiki/Constructive_solid_geometry">constructive solid geometry</a>.  The minimum of two distance functions is
the <b>union</b> and the maximum of two is their <b>intersection</b>.  Thinking
back to the thought experiment at the start of this chapter, and
considering several different boundaries and several respective GPS
devices, should make it obvious why.
</p>

<p>
The below code shows the intersection of two spheres; replace <code>max</code>
with <code>min</code> to instead see their union:
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-10' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float offset;

float distance(in vec3 pos)
{
    return max(length(pos + vec3(offset/2.0, 0, 0)) - 1.0,
               length(pos - vec3(offset/2.0, 0, 0)) - 1.0);
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-10' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 0.1,
       "min": 0,
       "max": 2,
       "name": "offset",
       "GUIName": "Offset"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float offset;

float distance(in vec3 pos)
{
    return max(length(pos + vec3(offset/2.0, 0, 0)) - 1.0,
               length(pos - vec3(offset/2.0, 0, 0)) - 1.0);
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-10').text());">Use code &raquo;</button></div>
</div>

<p>
Negating one of the shapes in a union can also subtract one shape from
another:
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-11' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float radius;

float distance(in vec3 pos)
{

    return max(-(length(pos) - radius),
               length(max(abs(pos).xyz - 1.0, 0.0)));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-11' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1.3,
       "min": 0,
       "max": 2,
       "name": "radius",
       "GUIName": "radius"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float radius;

float distance(in vec3 pos)
{

    return max(-(length(pos) - radius),
               length(max(abs(pos).xyz - 1.0, 0.0)));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-11').text());">Use code &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org162f3e8" class="outline-4">
<h4 id="org162f3e8"><span class="section-number-4"> 3.7.3</span> Domain warping</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
The last chapter used modulo in order to warp a function's domain into
an infinitely-repeating space in order to create a grid.  This works
identically here in 3 dimensions, due to the fact that we're working
with a function that maps 3D space to something:
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-12' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float radius;
uniform float offset;

float distance(in vec3 pos)
{
    vec3 pos2 = mod(pos, offset) - offset/2.0;
    return max(-(length(pos2) - radius),
               length(max(abs(pos2).xyz - 1.0, 0.0)));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-12' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1.3,
       "min": 0,
       "max": 2,
       "name": "radius",
       "GUIName": "radius"
   },
   {
       "type": "float",
       "value": 3,
       "min": 0,
       "max": 6,
       "name": "offset",
       "GUIName": "offset"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float radius;
uniform float offset;

float distance(in vec3 pos)
{
    vec3 pos2 = mod(pos, offset) - offset/2.0;
    return max(-(length(pos2) - radius),
               length(max(abs(pos2).xyz - 1.0, 0.0)));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-12').text());">Use code &raquo;</button></div>
</div>

<p>
This shows one interesting aspect of a sphere tracer: It lets us
represent an infinite amount of geometry without any additional
resource requirements.  Nowhere in here did we have to turn this
geometry into triangles.
</p>

<p>
We could take this further, and combine it with a rotation.  We could
make this rotation vary by distance from the origin as well.
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-13' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float radius;
uniform float offset;

float distance(in vec3 pos)
{
    float r = length(pos) / 20.0;
    mat3 rot = mat3(cos(r),  0,  sin(r),
                    0,       1,  0,
                    -sin(r), 0,  cos(r));

    vec3 pos2 = mod(pos * rot, offset) - offset/2.0;
    return max(-(length(pos2) - radius),
               length(max(abs(pos2).xyz - 1.0, 0.0)));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-13' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 1.3,
       "min": 0,
       "max": 2,
       "name": "radius",
       "GUIName": "radius"
   },
   {
       "type": "float",
       "value": 3,
       "min": 0,
       "max": 6,
       "name": "offset",
       "GUIName": "offset"
   }
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float radius;
uniform float offset;

float distance(in vec3 pos)
{
    float r = length(pos) / 20.0;
    mat3 rot = mat3(cos(r),  0,  sin(r),
                    0,       1,  0,
                    -sin(r), 0,  cos(r));

    vec3 pos2 = mod(pos * rot, offset) - offset/2.0;
    return max(-(length(pos2) - radius),
               length(max(abs(pos2).xyz - 1.0, 0.0)));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-13').text());">Use code &raquo;</button></div>
</div>

<p>
Or, we could add a variable amount of rotation to a cube&#x2026; that is,
basically twist it like it's flexible:
</p>

<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-14' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float freq;
uniform float freq2;

float distance(in vec3 pos)
{
    float r = freq * pos.y;
    mat3 rot_y = mat3(cos(r),  0,  sin(r),
                      0,       1,  0,
                      -sin(r), 0,  cos(r));
    return length(max(abs(pos * rot_y).xyz - 1.0, 0.0));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-14' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 0.1,
       "min": -5,
       "max": 5,
       "name": "freq",
       "GUIName": "Freq"
   }   
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float freq;
uniform float freq2;

float distance(in vec3 pos)
{
    float r = freq * pos.y;
    mat3 rot_y = mat3(cos(r),  0,  sin(r),
                      0,       1,  0,
                      -sin(r), 0,  cos(r));
    return length(max(abs(pos * rot_y).xyz - 1.0, 0.0));
}

void main()
{
    vec2 uv = 2.0 * gl_FragCoord.xy/resolution.xy - 1.0;
    // Correct aspect:
    uv.x = uv.x * resolution.x / resolution.y;

    // Normalize mouse position:
    vec2 m = vec2(mouse.x/resolution.x, 1.0 - mouse.y/resolution.y);
    m.x = m.x * resolution.x / resolution.y;

    // Camera location &amp; target:
    vec3 camera_loc = vec3(-0.5+3.5*cos(6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(6.0*m.x));
    vec3 camera_target = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation and rendering:
    mat3 ca = setCamera(camera_loc, camera_target, 0.0);
    vec3 rd = ca * normalize(vec3(uv, 2.0));
    vec3 col = render(camera_loc, rd);

    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-14').text());">Use code &raquo;</button></div>
</div>
</div>
</div>
</div>


<div id="outline-container-org6fb0e0a" class="outline-3">
<h3 id="org6fb0e0a"><span class="section-number-3"> 3.8</span> Repeated cubes 1</h3>
<div class="outline-text-3" id="text-1-8">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-15' mode="ace/mode/glsl" readonly="true">#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float freq;
uniform float freq2;

float distance(in vec3 pos)
{
    vec3 pos_ = vec3(mod(pos.x, 2.0) - 1.0, pos.y, mod(pos.z, 2.0) - 1.0);
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);
    float res = min(sdPlane(pos),
                    udRoundBox(pos3-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
	float time = 15.0 + time;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-15' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 0.1,
       "min": -5,
       "max": 5,
       "name": "freq",
       "GUIName": "Freq"
   },
   {
       "type": "float",
       "value": 0.1,
       "min": -1,
       "max": 1,
       "name": "freq2",
       "GUIName": "Freq2"
   }   
]
END */
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float freq;
uniform float freq2;

float distance(in vec3 pos)
{
    vec3 pos_ = vec3(mod(pos.x, 2.0) - 1.0, pos.y, mod(pos.z, 2.0) - 1.0);
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);
    float res = min(sdPlane(pos),
                    udRoundBox(pos3-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
	float time = 15.0 + time;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-15').text());">Use code &raquo;</button></div>
</div>
</div>
</div>


<div id="outline-container-org715d99c" class="outline-3">
<h3 id="org715d99c"><span class="section-number-3"> 3.9</span> Repeated cubes 2</h3>
<div class="outline-text-3" id="text-1-9">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-16' mode="ace/mode/glsl" readonly="true">
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float dx;
uniform float dz;

float distance(in vec3 pos)
{
    float ca_d = cos(0.05 * length(pos) + time*0.1);
    float sa_d = sin(0.05 * length(pos) + time*0.1);
    vec3 pos_ = pos;
    pos_ = vec3(pos_.x * ca_d - pos_.y * sa_d, pos_.x * sa_d + pos_.y * ca_d, pos_.z);
    
    float ca_d2 = cos(0.05 * length(pos) + time*0.2);
    float sa_d2 = sin(0.05 * length(pos) + time*0.2);
    //pos_ = vec3(pos_.x, pos_.y * ca_d2 - pos_.z * sa_d2, pos_.y * sa_d2 + pos_.z * ca_d2);

    pos_ = vec3(mod(pos_.x, dx) - dx/2.0, pos_.y, mod(pos_.z, dz) - dz/2.0);
    /*
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);*/
    float res = udRoundBox(pos_-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05);
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-16' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 2,
       "min": 1,
       "max": 10,
       "name": "dx",
       "GUIName": "dx"
   },
   {
       "type": "float",
       "value": 2,
       "min": 1,
       "max": 10,
       "name": "dz",
       "GUIName": "dz"
   }   
]
END */

#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float dx;
uniform float dz;

float distance(in vec3 pos)
{
    float ca_d = cos(0.05 * length(pos) + time*0.1);
    float sa_d = sin(0.05 * length(pos) + time*0.1);
    vec3 pos_ = pos;
    pos_ = vec3(pos_.x * ca_d - pos_.y * sa_d, pos_.x * sa_d + pos_.y * ca_d, pos_.z);
    
    float ca_d2 = cos(0.05 * length(pos) + time*0.2);
    float sa_d2 = sin(0.05 * length(pos) + time*0.2);
    //pos_ = vec3(pos_.x, pos_.y * ca_d2 - pos_.z * sa_d2, pos_.y * sa_d2 + pos_.z * ca_d2);

    pos_ = vec3(mod(pos_.x, dx) - dx/2.0, pos_.y, mod(pos_.z, dz) - dz/2.0);
    /*
    float ca = cos(freq * pos_.y);
    float sa = sin(freq * pos_.y);
    vec3 pos2 = vec3(pos_.x * ca - pos_.z * sa, pos_.y, pos_.x * sa + pos_.z * ca);
    float ca2 = cos(freq2 * pos2.z);
    float sa2 = sin(freq2 * pos2.z);
    vec3 pos3 = vec3(pos2.x * ca2 - pos2.y * sa2, pos2.x * sa2 + pos2.y * ca2, pos2.z);*/
    float res = udRoundBox(pos_-vec3(0.0, 0.5, 0.0), vec3(0.5), 0.05);
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-16').text());">Use code &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org67aab5c" class="outline-3">
<h3 id="org67aab5c"><span class="section-number-3"> 3.10</span> Repeated cubes 3</h3>
<div class="outline-text-3" id="text-1-10">
<div class="org-src-container">
<juicy-ace-editor id='webgl-juicy-ace-editor-17' mode="ace/mode/glsl" readonly="true">
#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float dist;

float distance(in vec3 pos)
{
    vec3 pos_ = mod(pos, dist) - dist/2.0;
    float res = sdBox(pos_, vec3(0.5));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</juicy-ace-editor><div id='webgl-full-code-17' style='display:none'>/* PARAMETERS
[
   {
       "type": "float",
       "value": 2,
       "min": 1,
       "max": 10,
       "name": "dist",
       "GUIName": "Dist"
   }   
]
END */

#define ENABLE_SPHERE_TRACING

uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float dist;

float distance(in vec3 pos)
{
    vec3 pos_ = mod(pos, dist) - dist/2.0;
    float res = sdBox(pos_, vec3(0.5));
    return res;
}

void main()
{
    vec2 mo = mouse.xy/resolution.xy;
    
    vec3 tot = vec3(0.0);
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    // Camera location:
    vec3 ro = vec3(-0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x));
    // Camera target:
    vec3 ta = vec3(-0.5, 0.4, 0.5);
    
    // Camera-to-world transformation
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // ray direction
    vec3 rd = ca * normalize(vec3(p.xy, 2.0));

    // render	
    vec3 col = render(ro, rd);

    // gamma
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</div><div class='no-print' align="left"><button type="button" onclick="copy_code($('#webgl-full-code-17').text());">Use code &raquo;</button></div>
</div>
</div>
</div>


<div id="outline-container-org5a7be6e" class="outline-3">
<h3 id="org5a7be6e"><span class="section-number-3"> 3.11</span> Domain Warping</h3>
</div>

<div id="outline-container-org12bea95" class="outline-3">
<h3 id="org12bea95"><span class="section-number-3"> 3.12</span> Domain Repetition</h3>
</div>

<div id="outline-container-org20cea23" class="outline-3">
<h3 id="org20cea23"><span class="section-number-3"> 3.13</span> Summary</h3>
<div class="outline-text-3" id="text-1-13">
<p>
This concludes the tutorial - at least, until I write more.  The <a href="#" onclick="myModule.loadTutorial('./04_Final_Notes.html', null)">next
chapter</a> contains some other references that you may wish to read.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
