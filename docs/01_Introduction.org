#+Title: Introduction
#+Author: Chris Hodapp

* Introduction

** What this is

The purpose of this tutorial is to introduce you to some pieces of
linear algebra and analytic geometry - and to use visual, interactive
programming in WebGL as the context to do so.

Most explanation is given alongside bits of code which run directly in
the browser.  To the right of this content (or possibly elsewhere,
depending on your browser), you'll see a pane with a couple tabs.  The
whole point of this pane is to let you play around with this code, and
see results immediately - without having to install an entire
development environment, without having to manually adapt equations or
pseudocode, without having to build an entire framework to test
something simple, and without having any real risk that you will
destroy anything.

# TODO: Give a simple WebGL example here

Everything about this tutorial is open source.  Further, the code
that's included here, and any code that you'll write, is all "real"
code written in a standard language that runs in countless other
places (with a little adaptation) - it's simply fragment shaders
written in GLSL ([[https://en.wikipedia.org/wiki/OpenGL_Shading_Language][OpenGL Shading Language]]).  That is, I didn't invent a
toy programming language or API for this tutorial.  On top of that,
nearly anything you write could be translated easily to many other
shading languages (e.g. [[https://en.wikipedia.org/wiki/Cg_(programming_language)][Cg]], [[https://en.wikipedia.org/wiki/High-level_shader_language][HLSL]], [[https://en.wikipedia.org/wiki/RenderMan_Shading_Language][RSL]]) that work very similarly, or
really to any other language.

# TODO: Supply GitHub link above.

** Requirements

To make full use of this, you'll require:

- A browser that [[https://en.wikipedia.org/wiki/WebGL#Support][supports WebGL]], and has enabled it
- A graphics card that is fast enough for the demos here

This assumes some background:

- Some familiarity with some form of general programming - something
  like C, C++, Java, or JavaScript.
- Some minimal background in graphics.  You should know that pixels
  are used to represent images on a computer, and how colors are
  represented.
- Some background in algebra and geometry.  You should know what a
  coordinate plane is.

** What this is not

This tutorial is not:

- An introduction to web programming in general - including with
  WebGL.  Other tutorials better serve that task, such as [[https://webglfundamentals.org/][WebGL
  Fundamentals]].  This tutorial uses a fairly small part of what WebGL
  provides.
- A rigorous, formal treatment of the topic.  However, I do try to
  link to external resources of that sort where appropriate.
- An introduction into programming for those who have no experience
  whatsoever.

** Sub-heading

If you only want to show part of the code in the text, then you can enclose the
part of the code that you want to show with =BEGIN= / =END= comments:

#+BEGIN_SRC lean
namespace hide

-- BEGIN
constant and : Prop -> Prop -> Prop
-- END

end hide
#+END_SRC

** Texture

Courtesy of [[https://fabricecastel.github.io/blog/2015-08-03/main.html][Sphere Tracing 101]]

#+BEGIN_SRC glsl
uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

void main()
{
  vec2 uv = gl_FragCoord.xy/resolution.xy;
  float green = uv.x;
  gl_FragColor = vec4(0.0, green, 0.0, 1.0);
}
#+END_SRC

** Sphere Tracing

#+BEGIN_SRC glsl
uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

// camera attributes
// cameraDirection and cameraUp MUST be normalized
// (ie. their length must be equal to 1)
const vec3 cameraPosition_ = vec3(0.0, 0.0, 10.0);
const vec3 cameraDirection = vec3(0.0, 0.0, -1.0);
const vec3 cameraUp = vec3(0.0, 1.0, 0.0);

// ray computation vars
const float PI = 3.14159265359;
const float fov = 50.0;
const float fovx = PI * fov / 360.0;
float fovy = fovx * resolution.y/resolution.x;
float ulen = tan(fovx);
float vlen = tan(fovy);

float distanceToNearestSurface(vec3 p){
    return length(p) - 1.0;
}

bool intersectsWithWorld(vec3 p, vec3 dir){
  float dist = 0.0;
  for(int i = 0; i < 20; i++){
    float nearest = distanceToNearestSurface(p + dir*dist);
    if(nearest < 0.01) return true;
    dist += nearest;
  }
  return false;
}

void main()
{
    vec2 uv = gl_FragCoord.xy/resolution.xy;
  
    // generate the ray for this pixel
    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);
    vec3 nright = normalize(cross(cameraUp, cameraDirection));
    vec3 pixel = cameraPosition_ + cameraDirection +
                 nright*camUV.x*ulen + cameraUp*camUV.y*vlen;
    vec3 rayDirection = normalize(pixel - cameraPosition_);
    
    float collidedWithWorld = 0.0;
    if(intersectsWithWorld(cameraPosition_, rayDirection))
        collidedWithWorld = 1.0;
    
    gl_FragColor = vec4(collidedWithWorld, 0.0, 0.0, 1.0);
}
#+END_SRC

** Sphere Tracing, repeated

#+BEGIN_SRC glsl
uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float z_speed;
uniform float rot_speed;
uniform float twist;
uniform float fov;
uniform float hOffset, vOffset;
uniform float manualLod;

uniform sampler2D texture;

#define PI 3.1415926
#define PI_INVERSE 1.0/PI
#define DEG2PI 3.1415926/180.0
#define VELOCITY 0.1
#define TWIST 0.5
#define LONGITUDE_SCALE 1.0
#define LATITUDE_SCALE 2.0
#define EXP 1.0

void main()	{
	vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
	p.y *= resolution.y / resolution.x;

	float focalDistance = 1.0 / tan(fov * DEG2PI * 0.5);

	vec3 viewDirection = normalize(vec3(focalDistance, p.x, p.y));
	vec3 offsetViewPoint = vec3(0, hOffset, vOffset);

	float tmp = dot(viewDirection, offsetViewPoint);
	vec3 radialDirection = offsetViewPoint + (sqrt(tmp * tmp - dot(offsetViewPoint, offsetViewPoint) + 1.0) - tmp) * viewDirection;

	// Rotation
	vec2 rot = -vec2(mouse.z, mouse.w) / resolution * vec2(2.0*PI, PI);
	vec3 XAxis = vec3(cos(rot.y)*cos(rot.x), sin(rot.x), -cos(rot.x)*sin(rot.y));
	vec3 YAxis = vec3(-cos(rot.y)*sin(rot.x), cos(rot.x), sin(rot.y)*sin(rot.x));
	vec3 ZAxis = vec3(sin(rot.y), 0 , cos(rot.y));

	radialDirection = XAxis * radialDirection.x + YAxis * radialDirection.y + ZAxis * radialDirection.z;

	float longitude = atan(radialDirection.z, radialDirection.y) * PI_INVERSE * 0.5;
	float latitude  = 1.0 - atan(sqrt(radialDirection.y*radialDirection.y + radialDirection.z*radialDirection.z), radialDirection.x) * PI_INVERSE;

	// Apply non linear latitude mapping: we want the variation speed for circumferences to be constant along the latitudes
	float t = 1.0 - 2.0 * abs(latitude - 0.5);
    float h = pow(t, 0.5);
    float r = 1.0 + (h - 1.0) * sign(0.5 - latitude);
    latitude = r * 0.5;
        
	vec2 uv = vec2(
	    (longitude + latitude * twist) * LONGITUDE_SCALE + time * rot_speed * VELOCITY,
	    latitude * LATITUDE_SCALE + time * z_speed * VELOCITY);

    if(length(dFdx(uv) + dFdy(uv)) > 0.9)
    {
    	// avoids artifacts when longitude jumps from 0.5 to -0.5
    	float mipmapLevel = pow((1.0 - t), 20.0) * 10.0;
	    gl_FragColor = vec4(texture2DLodEXT(texture, uv, mipmapLevel).rgb, 1.0);
    }
	else
	{
	    gl_FragColor = vec4(texture2D(texture, uv).rgb, 1.0);	
	}
}
#+END_SRC

** Math test

