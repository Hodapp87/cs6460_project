#+Title: CS6460 Demo Content
#+Author: Chris Hodapp

* Heading

You can put lean code in a =BEGIN_SRC= / =END_SRC= block:

#+BEGIN_SRC lean
check nat.rec
#+END_SRC

** Sub-heading

If you only want to show part of the code in the text, then you can enclose the
part of the code that you want to show with =BEGIN= / =END= comments:

#+BEGIN_SRC lean
namespace hide

-- BEGIN
constant and : Prop -> Prop -> Prop
-- END

end hide
#+END_SRC

** Texture

Courtesy of [[https://fabricecastel.github.io/blog/2015-08-03/main.html][Sphere Tracing 101]]

#+BEGIN_SRC glsl
uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

void main()
{
  vec2 uv = gl_FragCoord.xy/resolution.xy;
  float green = uv.x;
  gl_FragColor = vec4(0.0, green, 0.0, 1.0);
}
#+END_SRC

** Sphere Tracing

#+BEGIN_SRC glsl
uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

// camera attributes
// cameraDirection and cameraUp MUST be normalized
// (ie. their length must be equal to 1)
const vec3 cameraPosition_ = vec3(0.0, 0.0, 10.0);
const vec3 cameraDirection = vec3(0.0, 0.0, -1.0);
const vec3 cameraUp = vec3(0.0, 1.0, 0.0);

// ray computation vars
const float PI = 3.14159265359;
const float fov = 50.0;
const float fovx = PI * fov / 360.0;
float fovy = fovx * resolution.y/resolution.x;
float ulen = tan(fovx);
float vlen = tan(fovy);

float distanceToNearestSurface(vec3 p){
    return length(p) - 1.0;
}

bool intersectsWithWorld(vec3 p, vec3 dir){
  float dist = 0.0;
  for(int i = 0; i < 20; i++){
    float nearest = distanceToNearestSurface(p + dir*dist);
    if(nearest < 0.01) return true;
    dist += nearest;
  }
  return false;
}

void main()
{
    vec2 uv = gl_FragCoord.xy/resolution.xy;
  
    // generate the ray for this pixel
    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);
    vec3 nright = normalize(cross(cameraUp, cameraDirection));
    vec3 pixel = cameraPosition_ + cameraDirection +
                 nright*camUV.x*ulen + cameraUp*camUV.y*vlen;
    vec3 rayDirection = normalize(pixel - cameraPosition_);
    
    float collidedWithWorld = 0.0;
    if(intersectsWithWorld(cameraPosition_, rayDirection))
        collidedWithWorld = 1.0;
    
    gl_FragColor = vec4(collidedWithWorld, 0.0, 0.0, 1.0);
}
#+END_SRC

** Sphere Tracing, repeated

#+BEGIN_SRC glsl
uniform vec2 resolution;
uniform vec4 mouse;
uniform float time;

uniform float z_speed;
uniform float rot_speed;
uniform float twist;
uniform float fov;
uniform float hOffset, vOffset;
uniform float manualLod;

uniform sampler2D texture;

#define PI 3.1415926
#define PI_INVERSE 1.0/PI
#define DEG2PI 3.1415926/180.0
#define VELOCITY 0.1
#define TWIST 0.5
#define LONGITUDE_SCALE 1.0
#define LATITUDE_SCALE 2.0
#define EXP 1.0

void main()	{
	vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
	p.y *= resolution.y / resolution.x;

	float focalDistance = 1.0 / tan(fov * DEG2PI * 0.5);

	vec3 viewDirection = normalize(vec3(focalDistance, p.x, p.y));
	vec3 offsetViewPoint = vec3(0, hOffset, vOffset);

	float tmp = dot(viewDirection, offsetViewPoint);
	vec3 radialDirection = offsetViewPoint + (sqrt(tmp * tmp - dot(offsetViewPoint, offsetViewPoint) + 1.0) - tmp) * viewDirection;

	// Rotation
	vec2 rot = -vec2(mouse.z, mouse.w) / resolution * vec2(2.0*PI, PI);
	vec3 XAxis = vec3(cos(rot.y)*cos(rot.x), sin(rot.x), -cos(rot.x)*sin(rot.y));
	vec3 YAxis = vec3(-cos(rot.y)*sin(rot.x), cos(rot.x), sin(rot.y)*sin(rot.x));
	vec3 ZAxis = vec3(sin(rot.y), 0 , cos(rot.y));

	radialDirection = XAxis * radialDirection.x + YAxis * radialDirection.y + ZAxis * radialDirection.z;

	float longitude = atan(radialDirection.z, radialDirection.y) * PI_INVERSE * 0.5;
	float latitude  = 1.0 - atan(sqrt(radialDirection.y*radialDirection.y + radialDirection.z*radialDirection.z), radialDirection.x) * PI_INVERSE;

	// Apply non linear latitude mapping: we want the variation speed for circumferences to be constant along the latitudes
	float t = 1.0 - 2.0 * abs(latitude - 0.5);
    float h = pow(t, 0.5);
    float r = 1.0 + (h - 1.0) * sign(0.5 - latitude);
    latitude = r * 0.5;
        
	vec2 uv = vec2(
	    (longitude + latitude * twist) * LONGITUDE_SCALE + time * rot_speed * VELOCITY,
	    latitude * LATITUDE_SCALE + time * z_speed * VELOCITY);

    if(length(dFdx(uv) + dFdy(uv)) > 0.9)
    {
    	// avoids artifacts when longitude jumps from 0.5 to -0.5
    	float mipmapLevel = pow((1.0 - t), 20.0) * 10.0;
	    gl_FragColor = vec4(texture2DLodEXT(texture, uv, mipmapLevel).rgb, 1.0);
    }
	else
	{
	    gl_FragColor = vec4(texture2D(texture, uv).rgb, 1.0);	
	}
}
#+END_SRC

** Math test

